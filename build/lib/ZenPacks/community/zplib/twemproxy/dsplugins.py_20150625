# Setup logging
import logging
log = logging.getLogger('zen.zplibTwemproxy')

# PythonCollector Imports
from ZenPacks.zenoss.PythonCollector.datasources.PythonDataSource import PythonDataSourcePlugin

# Twisted Imports
from twisted.internet.defer import inlineCallbacks, returnValue

import socket
import json
import pprint

class zplibTwemproxyDeviceData(PythonDataSourcePlugin):
    """ Twemproxy Device data source plugin """

    # List of device attributes you might need to do collection.
    proxy_attributes = (
        'zTwemproxyPort',
        )

    @classmethod
    def config_key(cls, datasource, context):
        # One call will get data for device and components
        #   so don't include context.id in the config_key return

	return (
	    context.device().id,
	    datasource.getCycleTime(context),
	    'zplibTwemproxyDeviceData',
	    )
    @classmethod
    def params(cls, datasource, context):
        # Don't need any params - zProperties passed as proxy_attributes
        return

    @inlineCallbacks
    def collect(self, config):

        # Define netcat procedure to actually get data
	def netcat(hostname, port, content, log):
	    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	    log.info('In netcat. hostname is %s and port is %s \n' % (hostname, port))
	    s.connect((hostname, port))
	    s.sendall(content)
	    s.shutdown(socket.SHUT_WR)
	    result=[]
	    while 1:
		data = s.recv(1024)
		if data == "":
		    break
		#print "Received:", repr(data)
		result.append(data)
	    #print "Connection closed."
	    s.close()
	    return ''.join(result)

        data = self.new_data()
        for datasource in config.datasources:
            if not datasource.zTwemproxyPort:
                # If no zTwemproxyPort then set to 22222
                datasource.zTwemproxyPort = '22222'

	    host = datasource.manageIp
	    port = int(datasource.zTwemproxyPort)
	    content = ''
            log.info('In for datasource loop. datasource is %s, host is %s, port is %s \n' % (datasource, host, port))
            try:
		s = yield netcat(host, port, content, log)
	    except Exception, e:
		log.error( "%s: %s", device.id, e)
                continue

            j_data = json.loads(s)
       	    for k,v in j_data.iteritems():
		if isinstance(v, dict):             #got a server pool
		    log.info('Pool %s\n' % (k))
		    poolName = k
		    for k1,v1 in v.iteritems():
			if isinstance(v1, dict):    # got a server
                            sp = k1.split(':')
			    server_addr = sp[0]
			    try:
				servername,serveralias,serveraddresslist = socket.gethostbyaddr(server_addr)
			    except:
				servername = server_addr
			    port = sp[1]
                            id = servername + '_' + port
                            if datasource.component == id:
                                for datapoint_id in (x.id for x in datasource.points):
                                    if not v1.has_key(datapoint_id):
                                        continue
                                    try:
                                        value = v1[datapoint_id]
                                    except (TypeError, ValueError):
                                        continue
				    dpname = '_'.join((datasource.datasource, datapoint_id))
				    data['values'][datasource.component][dpname] = (value, 'N')
			else:
                            # Then we have pool metrics
                            log.info(' Got pool data - datasource.component is %s and poolName is %s \n' % (datasource.component, poolName))
                            if datasource.component == poolName:
				for datapoint_id in (x.id for x in datasource.points):
                                    if not v.has_key(datapoint_id):
                                        continue
				    try:
					value = v[datapoint_id]
				    except (TypeError, ValueError):
					continue
				    dpname = '_'.join((datasource.datasource, datapoint_id))
				    data['values'][datasource.component][dpname] = (value, 'N')
        returnValue(data)

